//#include <iostream> // Подключение библиотеки для ввода и вывода данных
//#include <cmath> // Подключение библиотеки для математических функций
//#include <iomanip> // Подключение библиотеки для управления выводом
//#include <vector> // Подключение библиотеки для работы с векторами
//#include <tuple> // Подключение библиотеки для работы с кортежами
//
//using namespace std; // Использование пространства имен std
//
//static double f(double x) { // Объявление функции f(x)
//    return x * log(x + 1) - 1; // Реализация функции f(x)
//}
//
//static double df(double x) { // Объявление функции df(x)
//    return log(x + 1) + x / (x + 1); // Реализация производной функции f(x)
//}
//
//static double g(double x) { // Объявление функции g(x)
//    if (x < 0.0) return exp(1.0 / x) - 1; // Реализация функции g(x) для x < 0
//    else return 1.0 / log(x + 1); // Реализация функции g(x) для x >= 0
//}
//
//static void bisectionMethod(double a, double b, double eps, vector < tuple<double, double, double, double>>& bisection, double& res) {
//    // Объявление функции для метода половинного деления
//    int N = 0; // Инициализация счетчика итераций
//    while ((b - a) >= eps && N < 100) { // Пока не достигнута точность или не превышено максимальное количество итераций
//        double c = (a + b) / 2; // Вычисление середины интервала
//        bisection.emplace_back(N, a, b, b - a); // Добавление информации об итерации в вектор
//        if (f(c) == 0) { // Если найден корень
//            break; // Прекращаем итерации
//        }
//        else if (f(a) * f(c) < 0) { // Если знаки функции на концах интервала разные
//            b = c; // Сдвигаем правую границу интервала
//        }
//        else {
//            a = c; // Сдвигаем левую границу интервала
//        }
//        N++; // Увеличиваем счетчик итераций
//        res = c; // Запоминаем приближенное значение корня
//    }
//}
//
//static void NewtonMethod(double x0, double eps, vector < tuple<double, double, double, double>>& newton, double& res) {
//    // Объявление функции для метода Ньютона
//    int N = 0; // Инициализация счетчика итераций
//    while (abs(f(x0)) >= eps && N < 100) { // Пока не достигнута точность или не превышено максимальное количество итераций
//        double x1 = x0 - f(x0) / df(x0); // Вычисление следующего приближения корня
//        double razn = abs(x1 - x0); // Вычисление разницы между текущим и предыдущим приближениями
//        if (razn < 0.0001) razn = 0.0001; // Предотвращение деления на ноль
//        newton.emplace_back(N, x0, x1, razn); // Добавление информации об итерации в вектор
//        if (abs(x1 - x0) <= eps) { // Если достигнута необходимая точность
//            break; // Прекращаем итерации
//        }
//        x0 = x1; // Переходим к следующему приближению
//        N++; // Увеличиваем счетчик итераций
//        res = x0; // Запоминаем приближенное значение корня
//    }
//}
//
//static void simpleMethod(double x0, double eps, vector < tuple<double, double, double, double>>& simple, double& res) {
//    // Объявление функции для метода простых итераций
//    int N = 0; // Инициализация счетчика итераций
//    while (abs(g(x0)) >= eps && N < 100) { // Пока не достигнута точность или не превышено максимальное количество итераций
//        double x1 = g(x0); // Вычисление следующего приближения корня
//        if (abs(x1 - x0) < eps) { // Если достигнута необходимая точность
//            break; // Прекращаем итерации
//        }
//        simple.emplace_back(N, x0, x1, abs(x1 - x0)); // Добавление информации об итерации в вектор
//        x0 = x1; // Переходим к следующему приближению
//        N++; // Увеличиваем счетчик итераций
//        res = x0; // Запоминаем приближенное значение корня
//    }
//}
//
//int main() { // Основная функция программы
//    setlocale(LC_ALL, "ru"); // Установка локали для корректного отображения текста
//
//    double a = -1, b = 2, eps = 0.0001; // Задание начальных значений интервала и точности
//    double res; // Переменная для хранения результата
//    vector < tuple<double, double, double, double>> bisection; // Вектор для хранения результатов метода половинного деления
//    vector < tuple<double, double, double, double>> newton; // Вектор для хранения результатов метода Ньютона
//    vector < tuple<double, double, double, double>> simple; // Вектор для хранения результатов метода простых итераций
//
//    // Первый корень
//    bisectionMethod(a, b, eps, bisection, res); // Вызов метода половинного деления для первого корня
//    cout << "Метод половинного деления(первый корень):" << endl; // Вывод заголовка для первого корня
//    cout << "----------------------------------------------------------------------" << endl; // Вывод разделителя
//    cout << "N" << setw(20) << "a" << setw(20) << "b" << setw(20) << "b - a" << endl; // Вывод заголовков столбцов
//
//    for (tuple<double, double, double, double> i : bisection) { // Перебор результатов метода половинного деления
//        cout << get<0>(i) << setw(20) << get<1>(i) << setw(20) << get<2>(i) << setw(20) << get<3>(i) << endl; // Вывод информации об итерации
//    }
//
//    cout << endl; // Пустая строка для разделения вывода
//    cout << "Корень: " << res << endl; // Вывод найденного корня
//    cout << endl; // Пустая строка для разделения вывода
//
//    double x0 = -0.5; // Начальное приближение для метода Ньютона и простых итераций
//    NewtonMethod(x0, eps, newton, res); // Вызов метода Ньютона для первого корня
//
//    cout << "Метод Ньютона(первый корень):" << endl; // Вывод заголовка для первого корня
//    cout << "N" << setw(20) << "x0" << setw(20) << "x1" << setw(20) << "x1 - x0" << endl; // Вывод заголовков столбцов
//
//    for (tuple<double, double, double, double> i : newton) { // Перебор результатов метода Ньютона
//        cout << get<0>(i) << setw(20) << get<1>(i) << setw(20) << get<2>(i) << setw(20) << get<3>(i) << endl; // Вывод информации об итерации
//    }
//
//    cout << endl; // Пустая строка для разделения вывода
//    cout << "Корень: " << res << endl; // Вывод найденного корня
//    cout << endl; // Пустая строка для разделения вывода
//
//    simpleMethod(x0, eps, simple, res); // Вызов метода простых итераций для первого корня
//
//    cout << "Метод простых итераций(первый корень):" << endl; // Вывод заголовка для первого корня
//    cout << "N" << setw(20) << "x0" << setw(20) << "x1" << setw(20) << "x1 - x0" << endl; // Вывод заголовков столбцов
//
//    for (tuple<double, double, double, double> i : simple) { // Перебор результатов метода простых итераций
//        cout << get<0>(i) << setw(20) << get<1>(i) << setw(20) << get<2>(i) << setw(20) << get<3>(i) << endl; // Вывод информации об итерации
//    }
//
//    cout << endl; // Пустая строка для разделения вывода
//    cout << "Корень: " << res << endl; // Вывод найденного корня
//    cout << endl; // Пустая строка для разделения вывода
//    cout << "--------------------------------------------------------------" << endl; // Вывод разделителя
//
//    // Второй корень
//    bisection.clear(); // Очистка вектора для метода половинного деления
//    newton.clear(); // Очистка вектора для метода Ньютона
//    simple.clear(); // Очистка вектора для метода простых итераций
//
//    a = 0, b = 2; // Изменение интервала для второго корня
//    bisectionMethod(a, b, eps, bisection, res); // Вызов метода половинного деления для второго корня
//
//    cout << "Метод половинного деления(Второй корень):" << endl; // Вывод заголовка для второго корня
//    cout << "N" << setw(20) << "a" << setw(20) << "b" << setw(20) << "b - a" << endl; // Вывод заголовков столбцов
//
//    for (tuple<double, double, double, double> i : bisection) { // Перебор результатов метода половинного деления
//        cout << get<0>(i) << setw(20) << get<1>(i) << setw(20) << get<2>(i) << setw(20) << get<3>(i) << endl; // Вывод информации об итерации
//    }
//
//    cout << endl; // Пустая строка для разделения вывода
//    cout << "Корень: " << res << endl; // Вывод найденного корня
//    cout << endl; // Пустая строка для разделения вывода
//
//    x0 = 0.5; // Начальное приближение для метода Ньютона и простых итераций
//    NewtonMethod(x0, eps, newton, res); // Вызов метода Ньютона для второго корня
//
//    cout << "Метод Ньютона(Второй корень):" << endl; // Вывод заголовка для второго корня
//    cout << "N" << setw(20) << "x0" << setw(20) << "x1" << setw(20) << "x1 - x0" << endl; // Вывод заголовков столбцов
//
//    for (tuple<double, double, double, double> i : newton) { // Перебор результатов метода Ньютона
//        cout << get<0>(i) << setw(20) << get<1>(i)
//            << setw(20) << get<2>(i) << setw(20) << get<3>(i) << endl; // Вывод информации об итерации
//    }
//
//    cout << endl; // Пустая строка для разделения вывода
//    cout << "Корень: " << res << endl; // Вывод найденного корня
//    cout << endl; // Пустая строка для разделения вывода
//
//    simpleMethod(x0, eps, simple, res); // Вызов метода простых итераций для второго корня
//
//    cout << "Метод простых итераций(Второй корень):" << endl; // Вывод заголовка для второго корня
//    cout << "N" << setw(20) << "x0" << setw(20) << "x1" << setw(20) << "x1 - x0" << endl; // Вывод заголовков столбцов
//
//    for (tuple<double, double, double, double> i : simple) { // Перебор результатов метода простых итераций
//        cout << get<0>(i) << setw(20) << get<1>(i) << setw(20) << get<2>(i) << setw(20) << get<3>(i) << endl; // Вывод информации об итерации
//    }
//
//    cout << endl; // Пустая строка для разделения вывода
//    cout << "Корень: " << res << endl; // Вывод найденного корня
//
//    return 0; // Возврат нуля для завершения программы
//}
